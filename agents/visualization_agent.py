import os
import pandas as pd
from typing import Optional, List, TypedDict, Any, Dict

from pydantic import BaseModel, Field
from langgraph.graph import Graph
from langchain.chat_models import init_chat_model

from prompt import (
    visualization_recommend_steps_prompt,
    visualization_prompt,
    visualization_code_fix_prompt,
)
from utils.dataframe import get_dataframe_summary
from utils.regex import relocate_imports_inside_function
from utils.rag_tool import rag_retrieve_agentic
from utils.llm_utils import get_default_llm
from parsers import PythonOutputParser

from dotenv import load_dotenv

load_dotenv()

# 使用统一的LLM初始化
llm = get_default_llm()

class Router(BaseModel):
    """ a class for visualization python code generation """
    output: Optional[str] = Field(
        description="The output text generated by the model."
    )
    steps: Optional[List[str]] = Field(
        description="A list of steps to be followed for visualization."
    )

llm_router = llm.with_structured_output(Router) if llm else None

class VisualizationState(TypedDict):
    data: pd.DataFrame
    data_summary: str
    analysis_results: Optional[Dict[str, Any]]  # EDA results, model results
    recommended_steps: str
    visualization_code: str
    generated_plots: Optional[List[str]]
    error: Optional[str]
    retry_count: int

def get_data_summary(state: VisualizationState) -> VisualizationState:
    data_summary = get_dataframe_summary(state["data"])
    state["data_summary"] = "\n\n".join(data_summary)
    return state

def recommend_visualization_steps(state: VisualizationState, input: str, enable_rag: bool = True) -> VisualizationState:
    rag_context = ""
    if enable_rag:
        rag_context = rag_retrieve_agentic(
            context=state["data_summary"] + str(state.get("analysis_results", {})),
            task=input
        )
    
    # 准备分析结果的字符串表示
    analysis_results_str = ""
    if state.get("analysis_results"):
        analysis_results_str = f"Available analysis results: {list(state['analysis_results'].keys())}"
    
    prompt = visualization_recommend_steps_prompt.format(
        user_instructions=input,
        analysis_results=analysis_results_str,
        all_datasets_summary=state["data_summary"] + ("\n\n" + rag_context if rag_context else "")
    )
    output = llm_router.invoke(prompt)
    state["recommended_steps"] = "\n\n".join(output.steps) if output.steps else ""
    return state

def generate_visualization_code(state: VisualizationState) -> VisualizationState:
    print("\n=== 开始生成可视化代码 ===")
    print("基于以下步骤生成代码:")
    print(state["recommended_steps"])
    
    # 准备分析结果信息
    analysis_results_str = ""
    if state.get("analysis_results"):
        analysis_results_str = f"Available analysis results: {list(state['analysis_results'].keys())}"
    
    prompt = visualization_prompt.format(
        function_name="generate_visualizations",
        recommended_steps=state["recommended_steps"],
        analysis_results=analysis_results_str,
        all_datasets_summary=state["data_summary"]
    )
    output = llm.invoke(prompt)
    visualization_code = PythonOutputParser().parse(output.content)
    
    if "def generate_visualizations" not in visualization_code:
        print("警告: 生成的代码中未找到 generate_visualizations 函数定义")
        state["error"] = "生成的代码中缺少 generate_visualizations 函数定义"
    else:
        state["visualization_code"] = visualization_code
        print("\n生成的代码:")
        print(state["visualization_code"])
        os.makedirs("tmp", exist_ok=True)
        with open("tmp/generate_visualizations.py", "w") as f:
            f.write(state["visualization_code"])
    return state

def execute_visualization(state: VisualizationState) -> VisualizationState:
    print("\n=== 开始执行可视化生成 ===")
    try:
        local_namespace = {}
        exec(state["visualization_code"], globals(), local_namespace)
        if 'generate_visualizations' not in local_namespace:
            raise NameError("未能成功定义 generate_visualizations 函数")
        generate_visualizations = local_namespace['generate_visualizations']
        
        # 执行可视化生成
        state["generated_plots"] = generate_visualizations(
            state["data"], 
            state.get("analysis_results"), 
            output_dir="visualizations"
        )
        state["error"] = None
        
        print("可视化生成成功完成")
        print(f"生成了 {len(state['generated_plots'])} 个图表:")
        for plot in state["generated_plots"]:
            print(f"- {plot}")
            
    except Exception as e:
        state["error"] = str(e)
        print(f"可视化生成过程出错: {state['error']}")
        print("可视化代码:")
        print(state["visualization_code"])
        
    return state

def handle_error(state: VisualizationState, enable_rag: bool = True) -> VisualizationState:
    print(f"\n=== 处理错误 (第 {state['retry_count'] + 1} 次重试) ===")
    if state["error"] and state["retry_count"] < 3:
        print(f"当前错误: {state['error']}")
        rag_context = ""
        if enable_rag:
            rag_context = rag_retrieve_agentic(
                context=state["visualization_code"] + "\n" + (state["error"] or ""),
                task="修复可视化代码"
            )
        prompt = visualization_code_fix_prompt.format(
            function_name="generate_visualizations",
            code_snippet=state["visualization_code"],
            error=state["error"] + ("\n\n" + rag_context if rag_context else "")
        )
        output = llm.invoke(prompt)
        state["visualization_code"] = relocate_imports_inside_function(
            PythonOutputParser().parse(output.content)
        )
        print("\n修复后的代码:")
        print(state["visualization_code"])
        os.makedirs("tmp", exist_ok=True)
        with open("tmp/generate_visualizations.py", "w") as f:
            f.write(state["visualization_code"])
        state["retry_count"] += 1
        return state
    print("达到最大重试次数或无错误需要处理")
    return state

def manual_review(state: VisualizationState, user_instructions: str, enable_rag: bool = True) -> VisualizationState:
    print("\n=== 人工审核推荐的可视化步骤 ===")
    print("推荐的可视化步骤：")
    print(state["recommended_steps"])
    
    while True:
        user_input = input("是否接受推荐的可视化步骤？(y/n)：").strip().lower()
        if user_input in ("y", "n"):
            break
        print("无效输入，请输入 'y' 或 'n'。")
    if user_input == "n":
        while True:
            feedback = input("请简要说明你对推荐步骤的不满或希望改进的地方：\n")
            rag_context = ""
            if enable_rag:
                rag_context = rag_retrieve_agentic(
                    context=state["data_summary"] + "\n用户反馈: " + feedback,
                    task=user_instructions
                )
            
            analysis_results_str = ""
            if state.get("analysis_results"):
                analysis_results_str = f"Available analysis results: {list(state['analysis_results'].keys())}"
                
            prompt = visualization_recommend_steps_prompt.format(
                user_instructions=feedback,
                analysis_results=analysis_results_str,
                all_datasets_summary=state["data_summary"] + ("\n\n" + rag_context if rag_context else "")
            )
            output = llm_router.invoke(prompt)
            state["recommended_steps"] = "\n\n".join(output.steps) if output.steps else ""
            print("根据反馈生成的新可视化步骤：")
            print(state["recommended_steps"])
            while True:
                user_input = input("是否接受推荐的可视化步骤？(y/n)：").strip().lower()
                if user_input in ("y", "n"):
                    break
                print("无效输入，请输入 'y' 或 'n'。")
            if user_input == "y":
                break
    return state

def build_visualization_graph(user_instructions: str, enable_manual_review: bool = False, enable_rag: bool = True) -> Graph:
    workflow = Graph()
    workflow.add_node("get_summary", get_data_summary)
    workflow.add_node("recommend_steps", lambda state: recommend_visualization_steps(state, user_instructions, enable_rag))
    if enable_manual_review:
        workflow.add_node("manual_review", lambda state: manual_review(state, user_instructions, enable_rag))
    workflow.add_node("generate_code", generate_visualization_code)
    workflow.add_node("execute_visualization", execute_visualization)
    workflow.add_node("handle_error", lambda state: handle_error(state, enable_rag))
    workflow.add_node("end", lambda x: x)

    workflow.add_edge("get_summary", "recommend_steps")
    if enable_manual_review:
        workflow.add_edge("recommend_steps", "manual_review")
        workflow.add_edge("manual_review", "generate_code")
    else:
        workflow.add_edge("recommend_steps", "generate_code")
    workflow.add_edge("generate_code", "execute_visualization")
    workflow.add_conditional_edges(
        "execute_visualization",
        lambda x: x["error"] is not None and x["retry_count"] < 5,
        {
            True: "handle_error",
            False: "end"
        }
    )
    workflow.add_edge("handle_error", "execute_visualization")
    workflow.set_entry_point("get_summary")
    workflow.set_finish_point("end")
    return workflow.compile()

def run_visualization(data_path: str, input_text: str, analysis_results: Dict[str, Any] = None,
                     enable_manual_review: bool = False, enable_rag: bool = True) -> List[str]:
    """
    运行可视化生成的主函数
    
    Args:
        data_path: 数据文件路径
        input_text: 用户输入的可视化需求
        analysis_results: 之前分析的结果（EDA结果、模型结果等）
        enable_manual_review: 是否启用人工审核
        enable_rag: 是否启用RAG
    
    Returns:
        生成的图表文件路径列表
    """
    initial_state = VisualizationState(
        data=pd.read_csv(data_path),
        data_summary="",
        analysis_results=analysis_results,
        recommended_steps="",
        visualization_code="",
        generated_plots=None,
        error=None,
        retry_count=0
    )
    
    graph = build_visualization_graph(
        user_instructions=input_text, 
        enable_manual_review=enable_manual_review, 
        enable_rag=enable_rag
    )
    
    print("\n=== 可视化工作流图 ===")
    graph.get_graph().print_ascii()
    
    final_state = graph.invoke(initial_state)
    
    if final_state["generated_plots"] is not None:
        print("\n=== 可视化生成成功完成 ===")
        print(f"生成了 {len(final_state['generated_plots'])} 个图表文件")
        return final_state["generated_plots"]
    else:
        print("可视化生成失败")
        return []

def load_analysis_results(eda_results_path: str = None, model_results_path: str = None) -> Dict[str, Any]:
    """加载之前的分析结果"""
    analysis_results = {}
    
    if eda_results_path and os.path.exists(eda_results_path):
        import pickle
        with open(eda_results_path, "rb") as f:
            analysis_results["eda_results"] = pickle.load(f)
        print(f"已加载EDA结果: {eda_results_path}")
    
    if model_results_path and os.path.exists(model_results_path):
        import pickle
        with open(model_results_path, "rb") as f:
            analysis_results["model_results"] = pickle.load(f)
        print(f"已加载模型结果: {model_results_path}")
    
    return analysis_results

if __name__ == "__main__":
    # 示例使用
    data_path = "/Users/runkeruan/Desktop/RBM/data-agent-for-futures/output/engineered_cleaned_B.csv"
    input_text = "请为这份期货数据生成全面的可视化图表，包括价格走势、特征分布、相关性分析等"
    
    # 加载之前的分析结果（如果存在）
    analysis_results = load_analysis_results(
        eda_results_path="output/eda_results.pkl",
        model_results_path="output/model_results.pkl"
    )
    
    generated_plots = run_visualization(
        data_path=data_path,
        input_text=input_text,
        analysis_results=analysis_results,
        enable_manual_review=False,
        enable_rag=False
    ) 