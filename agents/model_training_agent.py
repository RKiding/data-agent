import os
import pandas as pd
from typing import Optional, List, TypedDict, Any, Dict
from tqdm import tqdm
import time

from pydantic import BaseModel, Field
from langgraph.graph import Graph
from langchain.chat_models import init_chat_model

from prompt import (
    model_training_recommend_steps_prompt,
    model_training_prompt,
    model_training_code_fix_prompt,
)
from utils.dataframe import get_dataframe_summary
from utils.regex import relocate_imports_inside_function
from utils.rag_tool import rag_retrieve_agentic
from utils.llm_utils import get_default_llm
from parsers import PythonOutputParser

from dotenv import load_dotenv

load_dotenv()

# 使用统一的LLM初始化
llm = get_default_llm()

class Router(BaseModel):
    """ a class for model training python code generation """
    output: Optional[str] = Field(
        description="The output text generated by the model."
    )
    steps: Optional[List[str]] = Field(
        description="A list of steps to be followed for model training."
    )

llm_router = llm.with_structured_output(Router) if llm else None

class ModelTrainingState(TypedDict):
    data: pd.DataFrame
    data_summary: str
    recommended_steps: str
    training_code: str
    model_results: Optional[Dict[str, Any]]
    error: Optional[str]
    retry_count: int
    target_variable: str
    problem_type: str  # 'classification', 'regression', 'clustering'
    sample_test_passed: bool  # 新增：小样本测试是否通过

def determine_problem_type(data: pd.DataFrame, target_variable: str) -> str:
    """根据目标变量确定问题类型"""
    if target_variable and target_variable in data.columns:
        target_series = data[target_variable]
        # 检查是否为数值型
        if pd.api.types.is_numeric_dtype(target_series):
            unique_values = target_series.nunique()
            # 如果唯一值很少，可能是分类问题
            if unique_values <= 10:
                return "classification"
            else:
                return "regression"
        else:
            return "classification"
    else:
        return "regression"  # 默认为回归

def get_data_summary(state: ModelTrainingState) -> ModelTrainingState:
    data_summary = get_dataframe_summary(state["data"])
    state["data_summary"] = "\n\n".join(data_summary)
    
    # 自动确定问题类型
    if not state.get("problem_type"):
        state["problem_type"] = determine_problem_type(state["data"], state.get("target_variable", ""))
    
    # 初始化小样本测试状态
    state["sample_test_passed"] = False
    
    return state

def recommend_training_steps(state: ModelTrainingState, input: str, enable_rag: bool = True) -> ModelTrainingState:
    if not llm_router:
        state["error"] = "LLM未正确初始化"
        return state
        
    print("🔍 推荐训练步骤...")
    rag_context = ""
    if enable_rag:
        rag_context = rag_retrieve_agentic(
            context=state["data_summary"],
            task=input
        )
    prompt = model_training_recommend_steps_prompt.format(
        user_instructions=input,
        target_variable=state.get("target_variable", ""),
        problem_type=state.get("problem_type", "regression"),
        recommended_steps=None,
        all_datasets_summary=state["data_summary"] + ("\n\n" + rag_context if rag_context else "")
    )
    output = llm_router.invoke(prompt)
    state["recommended_steps"] = "\n\n".join(output.steps) if output.steps else ""
    return state

def generate_training_code(state: ModelTrainingState) -> ModelTrainingState:
    if not llm:
        state["error"] = "LLM未正确初始化"
        return state
        
    print("\n=== 开始生成模型训练代码 ===")
    print("基于以下步骤生成代码:")
    print(state["recommended_steps"])
    print(f"问题类型: {state.get('problem_type', 'regression')}")
    print(f"目标变量: {state.get('target_variable', 'None')}")
    
    # 添加小样本测试的提示
    enhanced_prompt = model_training_prompt.format(
        function_name="train_models",
        recommended_steps=state["recommended_steps"],
        target_variable=state.get("target_variable", ""),
        problem_type=state.get("problem_type", "regression"),
        all_datasets_summary=state["data_summary"]
    ) + """
    
    IMPORTANT: The function should support a 'sample_size' parameter for testing with small samples first.
    If sample_size is provided and > 0, use only that many rows for training.
    Also add progress tracking with tqdm for long-running operations.
    """
    
    with tqdm(total=1, desc="🤖 生成训练代码") as pbar:
        output = llm.invoke(enhanced_prompt)
        pbar.update(1)
    
    training_code = PythonOutputParser().parse(output.content)
    
    if "def train_models" not in training_code:
        print("警告: 生成的代码中未找到 train_models 函数定义")
        state["error"] = "生成的代码中缺少 train_models 函数定义"
    else:
        state["training_code"] = training_code
        print("\n生成的代码:")
        print(state["training_code"])
        os.makedirs("tmp", exist_ok=True)
        with open("tmp/train_models.py", "w") as f:
            f.write(state["training_code"])
    return state

def run_sample_test(state: ModelTrainingState) -> ModelTrainingState:
    """运行小样本测试"""
    print("\n=== 开始小样本测试 (100条记录) ===")
    try:
        local_namespace = {}
        exec(state["training_code"], globals(), local_namespace)
        if 'train_models' not in local_namespace:
            raise NameError("未能成功定义 train_models 函数")
        train_models = local_namespace['train_models']
        
        # 使用小样本测试
        sample_size = min(100, len(state["data"]))
        print(f"使用 {sample_size} 条记录进行测试...")
        
        with tqdm(total=1, desc="🧪 小样本测试") as pbar:
            # 尝试调用函数（可能需要修改函数签名支持sample_size参数）
            try:
                test_results = train_models(state["data"], state.get("target_variable"), sample_size=sample_size)
            except TypeError:
                # 如果不支持sample_size参数，就用前100行
                test_data = state["data"].head(sample_size)
                test_results = train_models(test_data, state.get("target_variable"))
            pbar.update(1)
        
        if test_results and isinstance(test_results, dict):
            state["sample_test_passed"] = True
            print("✅ 小样本测试通过！")
            print("测试结果包含以下组件:")
            for key in test_results.keys():
                print(f"  - {key}")
        else:
            raise Exception("小样本测试返回结果无效")
            
    except Exception as e:
        state["error"] = f"小样本测试失败: {str(e)}"
        print(f"❌ 小样本测试失败: {state['error']}")
        print("训练代码:")
        print(state["training_code"])
        
    return state

def execute_training(state: ModelTrainingState) -> ModelTrainingState:
    """执行完整模型训练"""
    if not state.get("sample_test_passed", False):
        print("⚠️ 跳过完整训练：小样本测试未通过")
        return state
        
    print("\n=== 开始执行完整模型训练 ===")
    try:
        local_namespace = {}
        exec(state["training_code"], globals(), local_namespace)
        if 'train_models' not in local_namespace:
            raise NameError("未能成功定义 train_models 函数")
        train_models = local_namespace['train_models']
        
        print(f"使用全部 {len(state['data'])} 条记录进行训练...")
        
        # 执行完整模型训练，带进度条
        with tqdm(total=1, desc="🚀 完整模型训练") as pbar:
            state["model_results"] = train_models(state["data"], state.get("target_variable"))
            pbar.update(1)
            
        state["error"] = None
        
        print("✅ 模型训练成功完成")
        print("训练结果包含以下组件:")
        for key in state["model_results"].keys():
            print(f"  - {key}")
            
        # 显示最佳模型信息
        if "best_model" in state["model_results"]:
            print(f"\n🏆 最佳模型: {type(state['model_results']['best_model']).__name__}")
        if "model_scores" in state["model_results"]:
            print("\n📊 模型性能对比:")
            for model_name, score in state["model_results"]["model_scores"].items():
                print(f"  {model_name}: {score:.4f}")
                
    except Exception as e:
        state["error"] = str(e)
        print(f"❌ 模型训练过程出错: {state['error']}")
        print("训练代码:")
        print(state["training_code"])
        
    return state

def handle_error(state: ModelTrainingState, enable_rag: bool = True) -> ModelTrainingState:
    if not llm:
        state["error"] = "LLM未正确初始化"
        return state
        
    print(f"\n=== 处理错误 (第 {state['retry_count'] + 1} 次重试) ===")
    if state["error"] and state["retry_count"] < 3:
        print(f"当前错误: {state['error']}")
        rag_context = ""
        if enable_rag:
            rag_context = rag_retrieve_agentic(
                context=state["training_code"] + "\n" + (state["error"] or ""),
                task="修复模型训练代码"
            )
        prompt = model_training_code_fix_prompt.format(
            function_name="train_models",
            code_snippet=state["training_code"],
            error=state["error"] + ("\n\n" + rag_context if rag_context else "")
        )
        output = llm.invoke(prompt)
        state["training_code"] = relocate_imports_inside_function(
            PythonOutputParser().parse(output.content)
        )
        print("\n修复后的代码:")
        print(state["training_code"])
        os.makedirs("tmp", exist_ok=True)
        with open("tmp/train_models.py", "w") as f:
            f.write(state["training_code"])
        state["retry_count"] += 1
        return state
    print("达到最大重试次数或无错误需要处理")
    return state

def manual_review(state: ModelTrainingState, user_instructions: str, enable_rag: bool = True) -> ModelTrainingState:
    if not llm_router:
        state["error"] = "LLM未正确初始化"
        return state
        
    print("\n=== 人工审核推荐的训练步骤 ===")
    print("推荐的训练步骤：")
    print(state["recommended_steps"])
    print(f"检测到的问题类型: {state.get('problem_type', 'regression')}")
    print(f"目标变量: {state.get('target_variable', 'None')}")
    
    while True:
        user_input = input("是否接受推荐的训练步骤？(y/n)：").strip().lower()
        if user_input in ("y", "n"):
            break
        print("无效输入，请输入 'y' 或 'n'。")
    if user_input == "n":
        while True:
            feedback = input("请简要说明你对推荐步骤的不满或希望改进的地方：\n")
            rag_context = ""
            if enable_rag:
                rag_context = rag_retrieve_agentic(
                    context=state["data_summary"] + "\n用户反馈: " + feedback,
                    task=user_instructions
                )
            prompt = model_training_recommend_steps_prompt.format(
                user_instructions=feedback,
                target_variable=state.get("target_variable", ""),
                problem_type=state.get("problem_type", "regression"),
                recommended_steps=state["recommended_steps"],
                all_datasets_summary=state["data_summary"] + ("\n\n" + rag_context if rag_context else "")
            )
            output = llm_router.invoke(prompt)
            state["recommended_steps"] = "\n\n".join(output.steps) if output.steps else ""
            print("根据反馈生成的新训练步骤：")
            print(state["recommended_steps"])
            while True:
                user_input = input("是否接受推荐的训练步骤？(y/n)：").strip().lower()
                if user_input in ("y", "n"):
                    break
                print("无效输入，请输入 'y' 或 'n'。")
            if user_input == "y":
                break
    return state

def build_training_graph(user_instructions: str, enable_manual_review: bool = False, enable_rag: bool = True) -> Graph:
    workflow = Graph()
    workflow.add_node("get_summary", get_data_summary)
    workflow.add_node("recommend_steps", lambda state: recommend_training_steps(state, user_instructions, enable_rag))
    if enable_manual_review:
        workflow.add_node("manual_review", lambda state: manual_review(state, user_instructions, enable_rag))
    workflow.add_node("generate_code", generate_training_code)
    workflow.add_node("run_sample_test", run_sample_test)
    workflow.add_node("execute_training", execute_training)
    workflow.add_node("handle_error", lambda state: handle_error(state, enable_rag))
    workflow.add_node("end", lambda x: x)

    workflow.add_edge("get_summary", "recommend_steps")
    if enable_manual_review:
        workflow.add_edge("recommend_steps", "manual_review")
        workflow.add_edge("manual_review", "generate_code")
    else:
        workflow.add_edge("recommend_steps", "generate_code")
    workflow.add_edge("generate_code", "run_sample_test")
    
    # 如果小样本测试通过，继续完整训练；如果失败，进入错误处理
    workflow.add_conditional_edges(
        "run_sample_test",
        lambda x: x["error"] is not None,
        {
            True: "handle_error",
            False: "execute_training"
        }
    )
    
    workflow.add_conditional_edges(
        "execute_training",
        lambda x: x["error"] is not None and x["retry_count"] < 5,
        {
            True: "handle_error",
            False: "end"
        }
    )
    workflow.add_edge("handle_error", "run_sample_test")  # 重试时重新开始小样本测试
    workflow.set_entry_point("get_summary")
    workflow.set_finish_point("end")
    return workflow.compile()

def run_model_training(data_path: str, input_text: str, target_variable: str = None, 
                      problem_type: str = None, enable_manual_review: bool = False, 
                      enable_rag: bool = True) -> Dict[str, Any]:
    """
    运行模型训练的主函数
    
    Args:
        data_path: 数据文件路径
        input_text: 用户输入的训练需求
        target_variable: 目标变量名称
        problem_type: 问题类型 ('classification', 'regression', 'clustering')
        enable_manual_review: 是否启用人工审核
        enable_rag: 是否启用RAG
    
    Returns:
        包含模型训练结果的字典
    """
    data = pd.read_csv(data_path)
    
    initial_state = ModelTrainingState(
        data=data,
        data_summary="",
        recommended_steps="",
        training_code="",
        model_results=None,
        error=None,
        retry_count=0,
        target_variable=target_variable or "",
        problem_type=problem_type or determine_problem_type(data, target_variable or ""),
        sample_test_passed=False  # 新增
    )
    
    graph = build_training_graph(
        user_instructions=input_text, 
        enable_manual_review=enable_manual_review, 
        enable_rag=enable_rag
    )
    
    print("\n=== 模型训练工作流图 ===")
    graph.get_graph().print_ascii()
    
    final_state = graph.invoke(initial_state)
    
    if final_state["model_results"] is not None:
        print("\n=== 模型训练成功完成 ===")
        # 保存模型结果
        os.makedirs("output", exist_ok=True)
        import pickle
        with open("output/model_results.pkl", "wb") as f:
            pickle.dump(final_state["model_results"], f)
        print("模型结果已保存到 'output/model_results.pkl'")
        
        # 保存最佳模型
        if "best_model" in final_state["model_results"]:
            with open("output/best_model.pkl", "wb") as f:
                pickle.dump(final_state["model_results"]["best_model"], f)
            print("最佳模型已保存到 'output/best_model.pkl'")
            
        return final_state["model_results"]
    else:
        print("模型训练失败")
        return None

if __name__ == "__main__":
    # 示例使用
    data_path = "/Users/runkeruan/Desktop/RBM/data-agent-for-futures/output/engineered_cleaned_B.csv"
    input_text = "请对这份期货数据进行机器学习建模，预测价格趋势或收益率"
    target_variable = None  # 根据实际情况设置目标变量，例如 "close_price" 或 "return"
    
    model_results = run_model_training(
        data_path=data_path,
        input_text=input_text,
        target_variable=target_variable,
        problem_type=None,  # 让系统自动检测
        enable_manual_review=False,
        enable_rag=False
    ) 