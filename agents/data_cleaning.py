import os
import pandas as pd
from typing import Optional, List, TypedDict

from pydantic import BaseModel, Field
from langgraph.graph import Graph
from langchain.chat_models import init_chat_model

from prompt import (
    cleaning_recommend_steps_prompt,
    cleaner_code_fix_prompt,
    data_cleaning_prompt,
)
from utils.dataframe import get_dataframe_summary
from utils.regex import relocate_imports_inside_function
from utils.rag_tool import rag_retrieve_agentic
from utils.llm_utils import get_default_llm
from parsers import PythonOutputParser

from dotenv import load_dotenv

load_dotenv()

# 使用统一的LLM初始化
llm = get_default_llm()

class Router(BaseModel):
    """ a class for data cleaning python code generation """
    output: Optional[str] = Field(
        description="The output text generated by the model."
    )
    steps: Optional[List[str]] = Field(
        description="A list of steps to be followed for data cleaning."
    )

llm_router = llm.with_structured_output(Router) if llm else None

# 定义状态类型
class DataCleaningState(TypedDict):
    data_raw: pd.DataFrame
    data_summary: str
    recommended_steps: str
    cleaning_code: str
    cleaned_data: Optional[pd.DataFrame]
    error: Optional[str]
    retry_count: int

# 定义节点函数
def get_data_summary(state: DataCleaningState) -> DataCleaningState:
    data_summary = get_dataframe_summary(state["data_raw"])
    state["data_summary"] = "\n\n".join(data_summary)
    return state

def recommend_cleaning_steps(state: DataCleaningState, input: str, enable_rag: bool = True) -> DataCleaningState:
    rag_context = ""
    if enable_rag:
        rag_context = rag_retrieve_agentic(
            context=state["data_summary"],
            task=input
        )
    prompt = cleaning_recommend_steps_prompt.format(
        user_instructions=input,
        recommended_steps=None,
        all_datasets_summary=state["data_summary"] + ("\n\n" + rag_context if rag_context else "")
    )
    output = llm_router.invoke(prompt)
    state["recommended_steps"] = "\n\n".join(output.steps) if output.steps else ""
    return state

def generate_cleaning_code(state: DataCleaningState) -> DataCleaningState:
    print("\n=== 开始生成清洗代码 ===")
    print("基于以下步骤生成代码:")
    print(state["recommended_steps"])
    
    prompt = data_cleaning_prompt.format(
        function_name="data_cleaner",
        recommended_steps=state["recommended_steps"],
        all_datasets_summary=state["data_summary"]
    )
    output = llm.invoke(prompt)
    cleaned_code = PythonOutputParser().parse(output.content)
    
    # 验证生成的代码是否包含必要的函数定义
    if "def data_cleaner" not in cleaned_code:
        print("警告: 生成的代码中未找到 data_cleaner 函数定义")
        state["error"] = "生成的代码中缺少 data_cleaner 函数定义"
    else:
        state["cleaning_code"] = cleaned_code
        print("\n生成的代码:")
        print(state["cleaning_code"])
        os.makedirs("tmp", exist_ok=True)
        with open("tmp/cleaner.py", "w") as f:
            f.write(state["cleaning_code"])
    return state

def execute_cleaning(state: DataCleaningState) -> DataCleaningState:
    print("\n=== 开始执行数据清洗 ===")
    try:
        # 创建本地命名空间
        local_namespace = {}
        
        # 在本地命名空间中执行代码
        exec(state["cleaning_code"], globals(), local_namespace)
        
        # 从本地命名空间中获取 data_cleaner 函数
        if 'data_cleaner' not in local_namespace:
            raise NameError("未能成功定义 data_cleaner 函数")
            
        # 执行数据清洗
        data_cleaner = local_namespace['data_cleaner']
        state["cleaned_data"] = data_cleaner(state["data_raw"])
        state["error"] = None
        
        print("数据清洗成功完成")
        print(f"数据形状: {state['cleaned_data'].shape}")
        
    except Exception as e:
        state["error"] = str(e)
        print(f"清洗过程出错: {state['error']}")
        print("清洗代码:")
        print(state["cleaning_code"])
        
    return state

def handle_error(state: DataCleaningState, enable_rag: bool = True) -> DataCleaningState:
    print(f"\n=== 处理错误 (第 {state['retry_count'] + 1} 次重试) ===")
    if state["error"] and state["retry_count"] < 3:
        print(f"当前错误: {state['error']}")
        rag_context = ""
        if enable_rag:
            rag_context = rag_retrieve_agentic(
                context=state["cleaning_code"] + "\n" + (state["error"] or ""),
                task="修复数据清洗代码"
            )
        prompt = cleaner_code_fix_prompt.format(
            function_name="data_cleaner",
            code_snippet=state["cleaning_code"],
            error=state["error"] + ("\n\n" + rag_context if rag_context else "")
        )
        output = llm.invoke(prompt)
        state["cleaning_code"] = relocate_imports_inside_function(
            PythonOutputParser().parse(output.content)
        )
        print("\n修复后的代码:")
        print(state["cleaning_code"])
        os.makedirs("tmp", exist_ok=True)
        with open("tmp/cleaner.py", "w") as f:
            f.write(state["cleaning_code"])
        state["retry_count"] += 1
        return state
    print("达到最大重试次数或无错误需要处理")
    return state

def manual_review(state: DataCleaningState, user_instructions: str, enable_rag: bool = True) -> DataCleaningState:
    print("\n=== 人工审核推荐的清洗步骤 ===")
    print("推荐的清洗步骤：")
    print(state["recommended_steps"])
    while True:
        user_input = input("是否接受推荐的清洗步骤？(y/n)：").strip().lower()
        if user_input in ("y", "n"):
            break
        print("无效输入，请输入 'y' 或 'n'。")
    if user_input == "n":
        while True:
            feedback = input("请简要说明你对推荐步骤的不满或希望改进的地方：\n")
            rag_context = ""
            if enable_rag:
                rag_context = rag_retrieve_agentic(
                    context=state["data_summary"] + "\n用户反馈: " + feedback,
                    task=user_instructions
                )
            prompt = cleaning_recommend_steps_prompt.format(
                user_instructions=feedback,
                recommended_steps=state["recommended_steps"],
                all_datasets_summary=state["data_summary"] + ("\n\n" + rag_context if rag_context else "")
            )
            output = llm_router.invoke(prompt)
            state["recommended_steps"] = "\n\n".join(output.steps) if output.steps else ""
            print("根据反馈生成的新清洗步骤：")
            print(state["recommended_steps"])
            while True:
                user_input = input("是否接受推荐的清洗步骤？(y/n)：").strip().lower()
                if user_input in ("y", "n"):
                    break
                print("无效输入，请输入 'y' 或 'n'。")
            if user_input == "y":
                break
    return state

# 构建图
def build_graph(user_instructions: str, enable_manual_review: bool = False, enable_rag: bool = True) -> Graph:
    # 创建工作流图
    workflow = Graph()

    # 添加节点
    workflow.add_node("get_summary", get_data_summary)
    workflow.add_node("recommend_steps", lambda state: recommend_cleaning_steps(state, user_instructions, enable_rag))
    if enable_manual_review:
        workflow.add_node("manual_review", lambda state: manual_review(state, user_instructions, enable_rag))
    workflow.add_node("generate_code", generate_cleaning_code)
    workflow.add_node("execute_cleaning", execute_cleaning)
    workflow.add_node("handle_error", lambda state: handle_error(state, enable_rag))
    workflow.add_node("end", lambda x: x)  # 添加结束节点

    # 设置边和条件
    workflow.add_edge("get_summary", "recommend_steps")
    if enable_manual_review:
        workflow.add_edge("recommend_steps", "manual_review")
        workflow.add_edge("manual_review", "generate_code")
    else:
        workflow.add_edge("recommend_steps", "generate_code")
    workflow.add_edge("generate_code", "execute_cleaning")
    
    # 添加条件分支
    workflow.add_conditional_edges(
        "execute_cleaning",
        lambda x: x["error"] is not None and x["retry_count"] < 5,
        {
            True: "handle_error",
            False: "end"
        }
    )
    workflow.add_edge("handle_error", "execute_cleaning")

    # 设置入口和出口
    workflow.set_entry_point("get_summary")
    workflow.set_finish_point("end")
    
    return workflow.compile()

def run_data_cleaning():
    enable_manual_review = True  # 控制人工审核
    enable_rag = False           # 控制是否启用RAG
    data_path = "/Users/runkeruan/Desktop/RBM/data-agent-for-futures/test_data/A.csv"
    input_text = "帮我清洗这份金融数据"  # 统一的 input
    initial_state = DataCleaningState(
        data_raw=pd.read_csv(data_path),
        data_summary="",
        recommended_steps="",
        cleaning_code="",
        cleaned_data=None,
        error=None,
        retry_count=0
    )
    graph = build_graph(user_instructions=input_text, enable_manual_review=enable_manual_review, enable_rag=enable_rag)
    # 打印图的ASCII表示
    print("\n=== 工作流图 ===")
    graph.get_graph().print_ascii()
    final_state = graph.invoke(initial_state)

    # 输出结果
    if final_state["cleaned_data"] is not None:
        print("Shape before cleaning:", final_state["data_raw"].shape)
        print("\nShape after cleaning:", final_state["cleaned_data"].shape)
        original_filename = os.path.splitext(os.path.basename(data_path))[0]
        os.makedirs("output", exist_ok=True)
        output_filename = os.path.join("output", f"cleaned_{original_filename}.csv")
        final_state["cleaned_data"].to_csv(output_filename, index=False)
        print(f"Cleaned data saved to '{output_filename}'")
    else:
        print("Data cleaning failed after all retries")

if __name__ == "__main__":
    main()