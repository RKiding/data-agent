import os
import pandas as pd
from typing import Optional, List, TypedDict, Any, Dict

from pydantic import BaseModel, Field
from langgraph.graph import Graph
from langchain.chat_models import init_chat_model

from prompt import (
    eda_recommend_steps_prompt,
    eda_analysis_prompt,
    eda_code_fix_prompt,
)
from utils.dataframe import get_dataframe_summary
from utils.regex import relocate_imports_inside_function
from utils.rag_tool import rag_retrieve_agentic
from utils.llm_utils import get_default_llm
from parsers import PythonOutputParser

from dotenv import load_dotenv

load_dotenv()

# 使用统一的LLM初始化
llm = get_default_llm()

class Router(BaseModel):
    """ a class for EDA python code generation """
    output: Optional[str] = Field(
        description="The output text generated by the model."
    )
    steps: Optional[List[str]] = Field(
        description="A list of steps to be followed for EDA analysis."
    )

# 检查LLM是否可用
if llm is None:
    print("❌ 警告: LLM未正确初始化，EDA功能可能无法正常工作")
    llm_router = None
else:
    llm_router = llm.with_structured_output(Router)

class EDAState(TypedDict):
    data: pd.DataFrame
    data_summary: str
    recommended_steps: str
    eda_code: str
    eda_results: Optional[Dict[str, Any]]
    error: Optional[str]
    retry_count: int
    target_variable: Optional[str]

def get_data_summary(state: EDAState) -> EDAState:
    data_summary = get_dataframe_summary(state["data"])
    state["data_summary"] = "\n\n".join(data_summary)
    return state

def recommend_eda_steps(state: EDAState, input: str, enable_rag: bool = True) -> EDAState:
    if llm_router is None:
        print("❌ 错误: LLM未初始化，无法推荐EDA步骤")
        state["error"] = "LLM未初始化"
        return state
    
    rag_context = ""
    if enable_rag:
        rag_context = rag_retrieve_agentic(
            context=state["data_summary"],
            task=input
        )
    prompt = eda_recommend_steps_prompt.format(
        user_instructions=input,
        target_variable=state.get("target_variable", ""),
        recommended_steps=None,
        all_datasets_summary=state["data_summary"] + ("\n\n" + rag_context if rag_context else "")
    )
    output = llm_router.invoke(prompt)
    state["recommended_steps"] = "\n\n".join(output.steps) if output.steps else ""
    return state

def generate_eda_code(state: EDAState) -> EDAState:
    print("\n=== 开始生成EDA代码 ===")
    print("基于以下步骤生成代码:")
    print(state["recommended_steps"])
    
    if llm is None:
        print("❌ 错误: LLM未初始化，无法生成EDA代码")
        state["error"] = "LLM未初始化"
        return state
    
    prompt = eda_analysis_prompt.format(
        function_name="perform_eda",
        recommended_steps=state["recommended_steps"],
        target_variable=state.get("target_variable", ""),
        all_datasets_summary=state["data_summary"]
    )
    output = llm.invoke(prompt)
    eda_code = PythonOutputParser().parse(output.content)
    
    if "def perform_eda" not in eda_code:
        print("警告: 生成的代码中未找到 perform_eda 函数定义")
        state["error"] = "生成的代码中缺少 perform_eda 函数定义"
    else:
        state["eda_code"] = eda_code
        print("\n生成的代码:")
        print(state["eda_code"])
        os.makedirs("tmp", exist_ok=True)
        with open("tmp/perform_eda.py", "w") as f:
            f.write(state["eda_code"])
    return state

def execute_eda(state: EDAState) -> EDAState:
    print("\n=== 开始执行EDA分析 ===")
    try:
        local_namespace = {}
        exec(state["eda_code"], globals(), local_namespace)
        if 'perform_eda' not in local_namespace:
            raise NameError("未能成功定义 perform_eda 函数")
        perform_eda = local_namespace['perform_eda']
        state["eda_results"] = perform_eda(state["data"])
        state["error"] = None
        print("EDA分析成功完成")
        print("分析结果包含以下组件:")
        for key in state["eda_results"].keys():
            print(f"- {key}")
    except Exception as e:
        state["error"] = str(e)
        print(f"EDA分析过程出错: {state['error']}")
        print("EDA代码:")
        print(state["eda_code"])
    return state

def handle_error(state: EDAState, enable_rag: bool = True) -> EDAState:
    print(f"\n=== 处理错误 (第 {state['retry_count'] + 1} 次重试) ===")
    if state["error"] and state["retry_count"] < 3:
        print(f"当前错误: {state['error']}")
        
        if llm is None:
            print("❌ 错误: LLM未初始化，无法修复代码")
            state["error"] = "LLM未初始化，无法修复代码"
            return state
        
        rag_context = ""
        if enable_rag:
            rag_context = rag_retrieve_agentic(
                context=state["eda_code"] + "\n" + (state["error"] or ""),
                task="修复EDA代码"
            )
        prompt = eda_code_fix_prompt.format(
            function_name="perform_eda",
            code_snippet=state["eda_code"],
            error=state["error"] + ("\n\n" + rag_context if rag_context else "")
        )
        output = llm.invoke(prompt)
        state["eda_code"] = relocate_imports_inside_function(
            PythonOutputParser().parse(output.content)
        )
        print("\n修复后的代码:")
        print(state["eda_code"])
        os.makedirs("tmp", exist_ok=True)
        with open("tmp/perform_eda.py", "w") as f:
            f.write(state["eda_code"])
        state["retry_count"] += 1
        return state
    print("达到最大重试次数或无错误需要处理")
    return state

def manual_review(state: EDAState, user_instructions: str, enable_rag: bool = True) -> EDAState:
    print("\n=== 人工审核推荐的EDA步骤 ===")
    print("推荐的EDA步骤：")
    print(state["recommended_steps"])
    
    if llm_router is None:
        print("❌ 错误: LLM未初始化，无法进行人工审核")
        state["error"] = "LLM未初始化"
        return state
    
    while True:
        user_input = input("是否接受推荐的EDA步骤？(y/n)：").strip().lower()
        if user_input in ("y", "n"):
            break
        print("无效输入，请输入 'y' 或 'n'。")
    if user_input == "n":
        while True:
            feedback = input("请简要说明你对推荐步骤的不满或希望改进的地方：\n")
            rag_context = ""
            if enable_rag:
                rag_context = rag_retrieve_agentic(
                    context=state["data_summary"] + "\n用户反馈: " + feedback,
                    task=user_instructions
                )
            prompt = eda_recommend_steps_prompt.format(
                user_instructions=feedback,
                target_variable=state.get("target_variable", ""),
                recommended_steps=state["recommended_steps"],
                all_datasets_summary=state["data_summary"] + ("\n\n" + rag_context if rag_context else "")
            )
            output = llm_router.invoke(prompt)
            state["recommended_steps"] = "\n\n".join(output.steps) if output.steps else ""
            print("根据反馈生成的新EDA步骤：")
            print(state["recommended_steps"])
            while True:
                user_input = input("是否接受推荐的EDA步骤？(y/n)：").strip().lower()
                if user_input in ("y", "n"):
                    break
                print("无效输入，请输入 'y' 或 'n'。")
            if user_input == "y":
                break
    return state

def build_eda_graph(user_instructions: str, enable_manual_review: bool = False, enable_rag: bool = True) -> Graph:
    workflow = Graph()
    workflow.add_node("get_summary", get_data_summary)
    workflow.add_node("recommend_steps", lambda state: recommend_eda_steps(state, user_instructions, enable_rag))
    if enable_manual_review:
        workflow.add_node("manual_review", lambda state: manual_review(state, user_instructions, enable_rag))
    workflow.add_node("generate_code", generate_eda_code)
    workflow.add_node("execute_eda", execute_eda)
    workflow.add_node("handle_error", lambda state: handle_error(state, enable_rag))
    workflow.add_node("end", lambda x: x)

    workflow.add_edge("get_summary", "recommend_steps")
    if enable_manual_review:
        workflow.add_edge("recommend_steps", "manual_review")
        workflow.add_edge("manual_review", "generate_code")
    else:
        workflow.add_edge("recommend_steps", "generate_code")
    workflow.add_edge("generate_code", "execute_eda")
    workflow.add_conditional_edges(
        "execute_eda",
        lambda x: x["error"] is not None and x["retry_count"] < 5,
        {
            True: "handle_error",
            False: "end"
        }
    )
    workflow.add_edge("handle_error", "execute_eda")
    workflow.set_entry_point("get_summary")
    workflow.set_finish_point("end")
    return workflow.compile()

def run_eda_analysis(data_path: str, input_text: str, target_variable: str = None, 
                     enable_manual_review: bool = False, enable_rag: bool = True) -> Dict[str, Any]:
    """
    运行EDA分析的主函数
    
    Args:
        data_path: 数据文件路径
        input_text: 用户输入的分析需求
        target_variable: 目标变量名称
        enable_manual_review: 是否启用人工审核
        enable_rag: 是否启用RAG
    
    Returns:
        包含EDA结果的字典
    """
    initial_state = EDAState(
        data=pd.read_csv(data_path),
        data_summary="",
        recommended_steps="",
        eda_code="",
        eda_results=None,
        error=None,
        retry_count=0,
        target_variable=target_variable
    )
    
    graph = build_eda_graph(
        user_instructions=input_text, 
        enable_manual_review=enable_manual_review, 
        enable_rag=enable_rag
    )
    
    print("\n=== EDA工作流图 ===")
    graph.get_graph().print_ascii()
    
    final_state = graph.invoke(initial_state)
    
    if final_state["eda_results"] is not None:
        print("\n=== EDA分析成功完成 ===")
        # 保存EDA结果
        os.makedirs("output", exist_ok=True)
        import pickle
        with open("output/eda_results.pkl", "wb") as f:
            pickle.dump(final_state["eda_results"], f)
        print("EDA结果已保存到 'output/eda_results.pkl'")
        return final_state["eda_results"]
    else:
        print("EDA分析失败")
        return None

if __name__ == "__main__":
    # 示例使用
    data_path = "/Users/runkeruan/Desktop/RBM/data-agent-for-futures/output/engineered_cleaned_B.csv"
    input_text = "请对这份期货数据进行全面的探索性数据分析，重点分析价格走势、成交量模式和各特征之间的关系"
    target_variable = None  # 根据实际情况设置目标变量
    
    eda_results = run_eda_analysis(
        data_path=data_path,
        input_text=input_text,
        target_variable=target_variable,
        enable_manual_review=False,
        enable_rag=False
    ) 